# API - OData Efficient Use of Query Capabilities

OData (Open Data Protocol) defines a set of best practices for building and consuming RESTful APIs.  OData supplies a minimal set of request query parameters that combine together to enable high levels of API endpoint re-usability and flexibility.

## OData supports the following request query parameters

* `$select` = Allows for returning a subset of properties.  This ensures bandwidth is not wasted returning properties that are not needed by the requestor.  A good example would be populating a `<select>` list with just names and id (`odata/users?$select=name,id`)
* `$filter` = Allows for returning a subset of objects.  This ensures bandwidth is not wasted returning objects that are not needed by the requestor.  A good example would be populating a `<table>`  with only active users (`odata/users?$filter=status eq ‘active’`)
* `$top` = Allows for returning a subset of objects not to exceed the given amount.  Example: `odata/users?$top=100` would return the first 100 objects or all objects if less than 100 exist
* `$skip` = When combined with $top, can be used for paging first skipping this many objects, then returning the amount given by $top.    Example: `odata/users?$top=10&$skip=20` would return page #3 with each page being 10 objects, and the first 20 objects being skipped.
* `$count` = Allows for returning the total count of how many objects would be returned based on any optional $filter.  If wanting to return just the count without the objects themselves, combine it with $top (`odata/users?$count=true&$top=0`)
* `$expand` = Allows for nesting child objects within their related parent objects.  This is a very effective way to return all needed data in the least amount of API calls.  Example: `odata/users?$expand=addresses` would return all user objects with each one having 0 or more nested address objects.  $expand can support multiple levels of nesting as in the example: ` odata/areas?$expand=divisions($expand=offices)`.  $expand also supports all other OData parameters at each expanded level contained within `()`, and separated by `;`
* `$orderBy` = Allows for server side sorting of the objects prior to their return.  It is strongly suggested to do all sorting at the client offload processing, and scaling linearly with the number of connected clients versus requiring the server to process all sorting requests on its static number of processors.  $orderBy can sort both ascending (asc) and decending (desc) as in the example `odata/users?$orderBy=lastName asc`.

## Best Practices

* ```Return no more data than is necessary``` - Combine OData parameters to return the absolute minimum data required by the requesting application ensuring the lowest bandwidth consumption, latency, and cost while simultaneously supplying the highest performance and scalability.  Below is an example of how these can be combined together in complex ways:

```http
odata/users?$select=id,firstName,lastName&$filter=status eq ‘active’&$top=10&$skip=0&$expand=addresses($select=zipCode;$filter=status eq ‘active’;$top=1)
```

* ```Data changing infrequently should be cached at the client``` - Many data properties rarely change such as a user's name, email or phone number, or a division office's name or physical address.  Calling the API to re-retrieve this data each time it is needed, causes unnecessary load on both the client and API, as well as wasting network bandwidth.  In these scenarios, caching these objects is preferred.  The closer the cache is to the client browser the better for best linear scalability and reduction on shared service resource or bandwidth usage.  Time to live (TTL) and forced update options should be implemented to allow application configuration options for best cache control.
* ```Share data across client components``` - Some common data will be used across multiple client-side components such as user or organization names or other details.  There is no need to have each component re-query the API for this data when a single API request could be made, and all components share the response.  Client side frameworks such as Angular/RxJs even allow for notifying all consuming components when any of them refresh the shared data.
* ```Ensure appropriate database indexing exists for frequently used OData queries``` - Although OData allows the flexibility for a client to pass any $filter or $expand properties, there is a strong possibility that the improper use of these can cause slow backend database performance and unnecessary resource consumption.  The larger the total number of object records or deeper the $expand, the more significant this can be.  You can initially use the OData `$count=true&$top=0` properties without a $filter to determine the total amount of data currently in the backend database for any given object.  For larger tables, ensure the API's backend database has been optimized for the given $filter and $expand being requested, or make the appropriate changes to either the database or OData query and needed.
* ```Call APIs in parallel where possible``` - Client-side frameworks such as Angular/RxJs have native capabilities for parallel API calls such as 'combineLatest', 'forkJoin', etc...  API calls should be made in parallel whenever one does not depend on the output of another.  This can have a significant improvement to the overall time to retrieve all needed data.  The 'network' tab from Chrome debugging tools is a great place to quickly notice serialized API calls.
* ```Make all remote calls asynchronously``` - All calls to your API should be made asynchronously as should calls from your API to any external service such as a backend database or to another remote API.  Making these calls asynchronously ensures your application does not block waiting for a response and is best able to continue to do other work while waiting for the remote service to respond.  This is frequently overlooked in code even when the developer understands and regularly follows this best practice.
* ```Keep API calls re-usable and loosely coupled``` - Even when proxying back to another remote API, it is always best to keep all API endpoints re-usable and loosely coupled.  This allows the client application to retain control of the OData properties passed through to the remote API, and reduces both the code required, and the work performed by the proxy API.  Basically, the proxy API simply passes along the request and responses without any serialization/deserialization, or model definitions.
* ```Leverage the linear scalability of the client``` - Server side processing does not scale linearly like client side does.  When doing things like sorting ($orderBy), take advantage of each client's dedicated processors rather than overworking the server makeing it handle all concurrent sorting requests.

## References

* OData Specification and detailed documentation - [odata.org]( https://www.odata.org/)
* See document [API - OData Setup for ASP.Net Core](https://github.com/PaulGilchrist/documents/blob/master/articles/api-odata-setup-for-dot-net-core.md) for proper implementation of OData
* See document [API - Swagger/Open API for ASP.Net Core using Swashbuckle](https://github.com/PaulGilchrist/documents/blob/master/articles/api-swagger-openapi-for-asp-net-core-using-swashbuckle.md) for proper configuration of OData controller function comments and annotation recomendations
* See [GitHub odate-core-template](https://github.com/PaulGilchrist/odata-core-template) for full source code of a working example of all above steps
